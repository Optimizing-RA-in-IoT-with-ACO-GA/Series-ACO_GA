# Series-ACO_GA

## Overview
The **Combined ACO-GA** method presents an integrated approach where **Ant Colony Optimization (ACO)** and **Genetic Algorithm (GA)** are merged into a single cohesive algorithm. This innovative strategy simultaneously leverages the unique strengths of both techniques, aiming to dynamically balance exploration and exploitation during the optimization process. By combining the pheromone-driven search of ACO with the evolutionary operators of GA, this method delivers more precise and efficient solutions.

## Algorithm Structure
The proposed combined algorithm consists of two main phases:

### 1. ACO-GA Integration Phase
In this phase, the algorithm generates an initial population of solutions using ACO principles. ACO creates paths based on pheromone trails, helping to identify promising areas in the problem space. These paths serve as the initial population for the GA.

### 2. Evolutionary Optimization Phase
In this phase, the paths generated by ACO are refined using GA techniques. Key operations include:
- **Selection**: Choosing the fittest solutions based on defined criteria.
- **Crossover**: Combining segments from different solutions to create new paths.
- **Mutation**: Introducing variability to maintain diversity within the population.

These genetic operations are applied iteratively over several generations, continuously improving the solutions. The integration of ACO's focus on promising search areas with GA's ability to maintain diversity enhances overall algorithm performance, achieving both local and global optimization effectively.

The flowchart of the proposed combined algorithm is illustrated below.
<p align="center">
  <img src="https://github.com/user-attachments/assets/c986b87e-8e35-4ed6-ae80-ac549fb26154"/>
</p>

## Pseudocode for ACO Phase
The provided pseudocode outlines the ACO phase in the hybrid optimization algorithm, focusing on how the ant colony explores and identifies optimal paths through the network. The `AntColony` class initializes key parameters such as the number of ants, iterations, decay rate, and the influence of pheromone (alpha) and heuristic information (beta). The `run` function executes the entire process, beginning with the initialization of a pheromone matrix and an empty list for storing the best paths. Each iteration involves generating all paths by simulating the ants’ movements, updating pheromone levels based on the quality of these paths, and then applying an evaporation factor to gradually reduce the influence of older paths. The `generate_path` function simulates an ant’s decision-making process, calculating the probability of moving based on pheromone levels and travel costs between nodes. These probabilities are influenced by the balance between exploration (pheromone levels) and exploitation (cost), and the path’s cost is calculated and added to the overall solution. The best paths are continuously extracted during iterations, ensuring that only the most cost-effective solutions are preserved. Finally, the `update_pheromone` function strengthens successful paths by increasing the pheromone levels along those paths in proportion to their effectiveness, guiding future ants toward these paths. This iterative process of exploration and pheromone reinforcement enables the algorithm to converge toward optimal or near-optimal solutions over time.

## Pseudocode for GA Phase
The provided pseudocode describes the GA phase, which is responsible for separating the solutions generated by the ACO phase. The `GeneticAlgorithm` class begins by initializing parameters such as the number of gateways, resources, population size, generations, and mutation rate. It then creates an initial population of solutions, either based on ACO input or new individuals. The algorithm iterates over a number of generations, where each generation includes the computation of individual fitness, selection of the best candidates based on their fitness, and the use of genetic operators like crossover and mutation to produce the next generation. This process continues until the population converges to an optimal or near-optimal solution, which is then returned as the final output.
